
### C++和C的区别
- C++面向对象，C面向过程的结构化编程语言
- C++具有封装继承多态
- C++相比C，增加许多类型安全的功能，比如强制类型转换
- C++支持范式编程、比如模板类、函数模板。

### 重点掌握<br>
- 指针和引用的概念
  - 指针是一个指向其他变量地址的变量
  - 引用：没有空引用，必须在创建时初始化，之后不再修改,引用知识一个别名。
<br>

    int (*p) [n];
      p是指向数组的指针
    int* p [n];
      p 是指针数组的数组名
    int* (*p) [n];
      p是指向指针数组的指针。
      
### Static
- 静态局部:静态存储区
    - 初始化
        - 内存中位置：Data_Segment
    - 未初始化
        - 内存中位置：BSS Segment
        - 作用：还是原来的语句结构当中，只不过是没有销毁依旧在内存当中，当函数再次被调用的时候，值不变。
- 静态全局变量：静态存储区
    - 作用域：从定义处开始到文件结尾，声明他的文件之外是看不见的（限制了原来的整个程序的范围）
    - 未初始化的话，自动初始化为0
- 静态函数
    - 只能在本CPP内使用的函数，解决不同CPP中同名函数的冲突
    - 如果要在多个CPP复用某个文件中的函数，那么就将它的声明提到它的头文件当中，否则需要在cpp文件内部加上static。不要在头文件当中声明static的全局函数，不要在cpp内声明非static的全局函数
- 类的静态成员
    - 所有类对象中共享的数据
- 类的静态函数
    - 同静态成员一样，都属于类的静态成员，而不是对象成员，因此使用静态成员的引用不需要对象名
    - 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。

### const


### cast转换
- const_cast
    - 用来添加或删除const特性
- static_cast
    - 任何编译器的隐式转换都可以由static_cast显式完成，void*转具体指针，较大的算数类型转化较小的类型，编译器不会出警告。
- dynamic_cast
- reinterpret_cast
    - 为安全使用该转换，需要程序员完全理解所设计的数据类型，以及编译器实现强制的转换细节。
- 为什么不使用C的转换
- C的转换表面看起来功能强大什么都能转换，但是转化不够明确，不能进行错误检查，容易出错。

### 指针和引用
- 指针
    - 一个变量，指向一内存地址
- 引用    
    - 一个变量的别名
- 区别
    - sizeof(ptr)=4 sizeof(引用)是引用对象的大小
    - 引用初始化必须是一个已有对象
    - 指针需要解引用才能操作对象
    - 有const指针，没有const引用
    - 指针可以改变指向谁，而引用不能
    - 指针可以有多级，引用只有一级
    - 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 
### 智能指针
- auto_ptr
    - 在C++11中被弃用
- unique_ptr
    - unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。
        ```C++
          unique_ptr<string> p3 (new string ("auto"));   //#4
          unique_ptr<string> p4；                       //#5
          p4 = p3;//此时会报错！！
        ```
  - 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 
     ```c++
    unique_ptr<string> pu1(new string ("hello world"));
    unique_ptr<string> pu2;
    pu2 = pu1;                                      // #1 not allowed
    unique_ptr<string> pu3;
    pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
    ```
- shared_ptr
    - 多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”reset时候释放。
    - 除了可以通过new来构造，还可以通过传入auto_ptr,unique_ptr,weak_ptr来构造
    - 对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。
     
- weak_ptr
     - 不控制对象生命周期的智能指针
     - weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。
     - 为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。
     - weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。
     - 不能通过weak_prt直接访问对象，要想使用应该将他转化为shared_ptr： shared_ptr=pa->pb_.lock();p->print()
     
 ### 数组和指针区别
 | | 指针|数组|
 | --- | --- | --- |
 | 内容| 保存数据地址|保存数据|
 | 访问方法 |间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据|直接访问数据|
 | 数据形式|通常用于动态的数据结构|通常用于固定数目且数据类型相同的元素| 
 |创建和删除 |通过Malloc分配内存，free释放内存|隐式的分配和删除|
 | 指向|通常指向匿名数据，操作匿名函数|自身即为数据名|
 
### 面向对象基础<br> 
 
### 虚函数
[C++虚函数的作用是什么——知乎](https://www.zhihu.com/question/23971699)
- 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。


- 纯虚函数
    - 让子类只是继承了父类的接口
    - 子类需要自己去定义自己的函数
    - 因为有一些父类中的那些函数存在性是不合理的，需要具体的被继承才有实际意义
    - 带有纯虚函数的类被称为抽象类
        - 抽象类不能定义对象
        - 如果派生类给出了基类纯虚函数的实现，那么派生类就不是抽象类了   

- 析构函数必须是虚函数
    - 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。 
    - C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 
    
- 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
- 多态[虚函数的文章](https://www.cnblogs.com/cxq0017/p/6074247.html)
    - 静态多态
        - 静态多态主要是重载，在编译的时候就已经确定
    - 动态多态
        - 动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
        - 虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销
        - 每一个含有虚函数的类都有虚表
            - 虚表是一个指向函数地址的一位数组
        - 子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。 
        

### RTTI 运行时类型识别
- dynamic_cast
- typeid
- type_info
  
### new/delete与malloc/free的区别
- 首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数
- malloc与new区别 
    - malloc需要给定申请内存的大小，返回的指针需要强转。
    - new会调用构造函数，不用指定内存大小，返回的指针不用强转。

