#### 虚函数
[C++虚函数的作用是什么——知乎](https://www.zhihu.com/question/23971699)
[C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现](https://blog.twofei.com/496/)

- 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

- 纯虚函数
    - 让子类只是继承了父类的接口
    - 子类需要自己去定义自己的函数
    - 因为有一些父类中的那些函数存在性是不合理的，需要具体的被继承才有实际意义
    - 带有纯虚函数的类被称为抽象类
        - 抽象类不能定义对象
        - 如果派生类给出了基类纯虚函数的实现，那么派生类就不是抽象类了   

- 析构函数必须是虚函数
    - 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。 
    - C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 
    
- 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

- 为什么构造函数不需要虚函数
    - 从语言的意义上来讲，C++的虚允许我们调用一个函数在只知道它的接口信息的情况下。构造一个对象，你需要全部的信息，所以你需要知道你现在构造的对象是什么类型的。
    - 从实际意义上看，当我们使用一个基类指针指向一个子类对象的时候，子类已经构造出来了，不需要构造上的多态。
    - 从实现上来看，从实现上看，vptr 指针在构造函数调用后才对其初始化，因而构造函数不可能成为虚函数  

- 多态[虚函数的文章](https://www.cnblogs.com/cxq0017/p/6074247.html)
    - 重载多态（静）：函数重载，运算法重载
    - 参数多态（静）：类模板，函数模板
    - 强制多态（动/静）：基本类型转换，自定义类型转换
    - 子类型多态（动）：虚函数
    - 静态多态
        - 静态多态主要是重载，在编译的时候就已经确定
    - 动态多态
        - 动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
        - 虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销
        - 每一个含有虚函数的类都有虚表
            - 虚表是一个指向函数地址的一位数组
        - 子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。 
    - 实现
        - 函数重载，重载在他的参数类型上
        - 运算法重载，非成员函数一般作为友元,算数操作符，相等，关系，位操作符都适合作为非成员函数进行重载，其它的都适合作为类成员进行重载
        - 类模板函数模板
        - 虚函数
        - 类型转换，自定义类型转换
