上下文切换
=============

### 原子上下文（是一个概念）atomic context
&emsp;在处理硬件中断or软件中断时，都在原子上下文当中。<br>
&emsp;任何内核代码在运行自旋锁时，同样处于原子上下文，只要睡眠，就会永远地死锁<br>
&emsp;&emsp;更高优先级的中断若试图得到这个自旋锁就死锁了<br>
- 运行在原子上下文的代码要注意
    1.不允许访问用户空间
    2.不允许睡眠
- 不能睡的原因
[关于LINUX在中断（硬软）中不能睡眠的真正原因 _CHINA_UNIX讨论帖](http://bbs.chinaunix.net/thread-2115820-1-1.html)<br>
&emsp;&emsp;1、 中断处理的时候,不应该发生进程切换，因为在中断context中，唯一能打断当前中断handler的只有更高优先级的中断，它不会被进程打断，如果在 中断context中休眠，则没有办法唤醒它，因为所有的wake_up_xxx都是针对某个进程而言的，而在中断context中，没有进程的概念，没 有一个task_struct（这点对于softirq和tasklet一样），因此真的休眠了，比如调用了会导致block的例程，内核几乎肯定会死。
&emsp;&emsp;2、保存的上下文不对，因为cpu上下文变成了处理中断的上下文
&emsp;&emsp;非要睡眠可以放在workqueue中，就是进程上下文去执行
- 为什么不能访问用户空间
    - 
### CPU上下文切换

    先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来
    加载新任务的上下文到这些寄存器和程序计数器
    最后再跳转到程序计数器所指的新位置，运行新任务
    保存下来的上下文，会存储到系统内核中，并在任务重新调度执行时再次加载进来，这样能保证任务原来的状态不受影响，让任务看起来还是连续运行


### 中断上下文

- 中断处理
    - 为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件
    - 在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行

- 和进程切换的不同点
    - 中断上下文切换并不涉及到进程的用户态
    - 即便中断过程打断了 一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源
    - 中断上下文，只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数
- 消耗资源
    -  进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能
    - 当发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题
       
### 系统调用上下文
&emps;&emps;系统调用上下文仍属于进程上下文当中，只不过从用户态到了内核态，发生了CPU上下文切换
        
        去执行了一个软中断的中断处理程序而已


### 进程上下文
[进程上下文和中断上下文](https://www.cnblogs.com/hustcat/articles/1505618.html?spm=a2c6h.12873639.0.0.3aaf6ab6PFw7y8)
 一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。主要都是tack_struct 那些洞悉
- 用户级上下文: 正文、数据、用户堆栈以及共享存储区；
- 寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
- 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。
- TLB的切换：参考:[多核MMU和ASID管理逻辑](https://zhuanlan.zhihu.com/p/118244515)
    - 如果TLB内部有ASID来区分那个价进程的页表，那么不需要刷新整个TLB
    - 否则需要刷新TLB
    
### 线程上下文

### 内核态用户态
- 内核态
    - 进程上下文的系统调用当中
    - 中断上下文中
- 用户态
    - 用户进程当中

参考：[性能测试必备知识（5）- 深入理解“CPU 上下文切换”](https://www.cnblogs.com/poloyy/p/13347635.html)




