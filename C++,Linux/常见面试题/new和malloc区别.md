new和malloc 区别
=========================
参考:[经典面试题之new和malloc的区别](https://blog.csdn.net/nie19940803/article/details/76358673)<br>
- 1.属性
    - new/delete 是C++关键字需要 编译器支持
    - malloc/free是库函数，需要头文件支持
- 2.参数
    - new不需要指明对象的大小
    - malloc需要指明具体大小
- 3.返回类型
    - new 返回是对象类型的地址类型严格与对象匹配，无须进行类型转换，
    - 而malloc内存分配成功则是返回void* ，需要通过强制类型转换将void*指针转换成我们需要的类型
- 4.分配失败
    - new内存分配失败时，会抛出bad_alloc异常。
        - bad_alloc原因 参考:[malloc最多能分配多少内存](http://fallincode.com/blog/2020/01/malloc%E6%9C%80%E5%A4%9A%E8%83%BD%E5%88%86%E9%85%8D%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/ )
            - 无法分出连续那么大的内存
            - “/proc/sys/vm/overcommit_memory”
                - 0: heuristic overcommit (this is the default)  
                - 1: always overcommit, never check  
                - 2: always check, never overcommit
            - 在 x86_64系统当中，分配不超过1<<47大内存，因为48位物理内存地址，48~63位必须和47位保持一致  
    - malloc分配内存失败时返回NULL。
- 5.过程区别
    - new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
    - malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
- 6.重载
    - C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址
    - malloc不能重载
- 7.内存区域
    - 通过new 的重载 new 分配的内存就大可不必在heap区了就比如一个全局变量开的内存池，总之new的来源称之为自由存储区（仅仅是一个名字)。这两者的概念可以看下[C++ 自由存储区是否等价于堆？](https://www.cnblogs.com/qg-whz/p/5060894.html)
    - 而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。