全过程
======

- 预处理
    - 将include的内容都赋值过来，
    - define的赋值过来
- 编译、汇编
    - 编译前端
      - 词法分析
      - 语法分析
      - 语义分析  
    
    - 编译后端
      - 中间代码生成
      - 代码优化
      - 机器代码生成
- 链接
- 装载
  - 可能发生装载时的动态链接
   - 覆盖装入和页映射
      - 页映射
        - 内存和所有磁盘中的数据和指令按照”页(Page)”为单位划分成若干个页，
          以后所有的装载和操作的单位都是页。
          
- 执行

### Linux系统的bash下输入一个命令执行某个ELF程序时
- 参考[可执行文件的装载与进程](https://zhuanlan.zhihu.com/p/127821301)
- bash进程fork出一个子线程
    - 该子线程调用execve()系统调用执行指定的ELF文
    - 原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令
- execve()->sys_execve()->do_execve()
    - do_execve()如果找到了文件，那么读取前128字节，判断文件格式
    - 开头4字节为魔数，确定文件格式和类型，之后就对后面的字符串进行解析，以确定具体的解释程序的路径。
        - 使用search_binary_handle()函数查找对应的可执行文件加载函数
            - ELF:load_elf_binary()
            - a.out: load_aout_binary()
            - 脚本 :load_script()

    - load_elf_binary()
        - 检查ELF可执行文件格式的有效性,比如魔术，还有头表中segment数量
        - 寻找动态链接的”.interp”段，设置动态链接器路径
        - 根据ELF文件的程序头表的描述，对ELF文件进行**映射**，比如代码、数据、只读数据。
        - 初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。
        - 将系统调用的返回地址修改成ELF可执行文件的入口点
        - 返回
    
    - 上面步骤都返回之后，当sys_execve()系统调用从内核态返回到用户态时，
      EIP寄存器(类似于PC寄存器)直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件加载完成。

