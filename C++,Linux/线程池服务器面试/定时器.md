定时器
=============

### 为什么使用定时器？
- 一些不活跃的socket会占fd的数量，还有一些其他的内核资源，应该及时处理
- 那么fd占哪些资源呢
    - 可以看下计网/面试题中的文章
### 定时器原理
- 目前使用是 ：升链表定时器管理定时事件
- 有连接建立or数据传输就创建你或者更新定时器
- 内部使用双向链表管理
- alarm信号
    - 采用统一事件源技术，将alarm信号的处理事件为向pipefd写当前信号,pipefd已经放入epoll当中
    - epoll poll出来后执行timer_handler()
    - timer_hanler()
        - tick()：对已经超时的事件执行并且删除
        - alarm(TIMESLOT)
- 复杂度
    - 插入 O(n)
    - 删除 O(1)
    - 执行 O(1)
### 优化
- 可以采用时间轮
    - 原理
        - 
    - 复杂度
        - 插入O(1)，直接插入到每个槽位的头结点
        - 删除O(1):相当于链表的删除
        - 更新：相当于删除加插入
        - 执行一个定时器的复杂度是O(n)，但是特别多的槽位的情况下是接近O(1)
            
- 再优化还有分层时间轮：参考：[令人惊艳的时间轮算法（TimingWheel）](https://yfscfs.gitee.io/post/%E4%BB%A4%E4%BA%BA%E6%83%8A%E8%89%B3%E7%9A%84%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95timingwheel/)
    - 原理
        - 将一天的时间分成 小时轮，分钟轮，和秒轮
        - 如果超时时间不在当前的小时下标当中，那么挂到应该去的小时下标
        - 当转到一个已经在小时下标的内容里时，放入第二层，并且去掉分钟信息，也就是在分钟层只保留秒数信息，因为分钟层的下标已经表达了分钟
        - 类似上面的过程最终将定时器放到了最下层，秒轮执行定时器


