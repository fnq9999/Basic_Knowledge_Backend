排序
=====
<img src="https://pic3.zhimg.com/80/v2-585dfed0da1375e11565ebbc9d40227b_720w.jpg" width="50%"/>

- 冒泡
  - 把大的一点点挪到最后面。
  - 优化过的算法最优复杂度O(N)
- 选择
<br>
<img src= "https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" width="20%"/>
- 插入
<br>
<img src= "https://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" width="20%"/>
- 快排
- 基数
- 希尔

- 桶排序
- leetcode  164最大间距
  -给你一个无序数组，问你排完序之后，相邻两个元素的差值的最大值是多少？O(N)时间。
```c++
struct bkt
{
	bool used = false;
	int mx = INT_MIN;
	int mi = INT_MAX;
};
class Solution {
public:
	int maximumGap(vector<int>& nums) {
		if (nums.size() < 2)
			return 0;
		int res = 0;
		//nums里面最大最小值
        #define inf 0x3f3f3f3f
        int maxnum=-inf;
        int minnum=inf;
        for(int i=0;i<nums.size();++i){
            maxnum=max(maxnum,nums[i]);
            minnum=min(minnum,nums[i]);
        }
		//桶容量大小
        int bktsz=max(1,int((maxnum-minnum)/(nums.size()-1)));
		//对于bucketSize=0情况，桶大小为0，每个桶里一个元素都存不满，是因为nums中存在大量重复元素
		//桶个数
		int bktnum=(maxnum-minnum)/(bktsz)+1;
		//每个桶里只保存桶中最大元素和最小元素
		vector<bkt> bkts(bktnum);
		for (auto& v : nums)
		{
			int pos = (v - minnum) / bktsz;
			bkts[pos].used = true;
			bkts[pos].mx = max(bkts[pos].mx, v);
			bkts[pos].mi = min(bkts[pos].mi, v);
		}
		int pre = minnum;
		//遍历每个桶，最大间距出现在两个桶里的元素差值里
		for (int i = 0; i < bkts.size(); i++)
		{
			if (!bkts[i].used)
				continue;
			//当前桶里最小值和前一个桶里最大值的差值可能是nums的最大间距
			res = max(res, bkts[i].mi - pre);
			//前一个桶的最大值
			pre = bkts[i].mx;
		}
		return res;
	}
};



```


gif 源自于 [wiki](https://zh.wikipedia.org/zh-cn/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
