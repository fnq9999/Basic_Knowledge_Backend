### leetcode 1326 灌溉花园的最少水龙头 <br>
    告诉你n,有n+1个点，每个点都有一个水龙头，每个水龙头覆盖的范围是range[i],问最少需要多少
    水龙头，覆盖全部n+1点
    解：
      再读入数据的时候，维护right[i]表示i这个点最远能覆盖多远,然后从左到右如果能顺利遍历下去，就说明可以。
```c++
class Solution {
    public:
        int minTaps(int n, vector<int>& ranges) {
            vector<int>right(n+1,0);
            for(int i=0;i<ranges.size();i++){
                int l=max(0,i-ranges[i]);
                int r=min(n,i+ranges[i]);
                right[l]=max(right[l],r);
            }
            int maxright=0,ans=0,further=0;
            for(int i=0;i<n;++i){
                further=max(further,right[i]);///水最远能喷到哪里
                if(i==maxright){
                    if(further<=maxright)return -1;
                    ++ans;
                    maxright=further;
                }
            }
            return ans;
        }
    };
```


### leetcode 135 发糖果 <br>
    每个孩子至少分配到 1 个糖果。
    相邻的孩子中，评分高的孩子必须获得更多的糖果。
    解法：
      正一边遍历，满足规则的分配方法，
      反再来一遍，就可以了
      每一个i取正反两次遍历里面较大值。
```c++
class Solution {
public:
    vector<pair<int,int>>vec;
    int candy(vector<int>& ratings) {
        for(int i=0;i<ratings.size();++i){
            vec.push_back({ratings[i],i});
        }
        vector<int>ans(vec.size(),0);
        sort(vec.begin(),vec.end());
        int ind,val;
        int cnt=0;
        for(int i=0;i<vec.size();++i){
            ind=vec[i].second;
            val=vec[i].first;
            ans[ind]=1;
            if(ind!=0){
                if(ratings[ind-1]<val){
                    ans[ind]=max(ans[ind],ans[ind-1]+1);
                }
            }
            if(ind!=vec.size()-1){
                if(ratings[ind+1]<val){
                    ans[ind]=max(ans[ind],ans[ind+1]+1);
                }
            }
            cnt+=ans[ind];
        }
        return cnt;
    }
};
```
