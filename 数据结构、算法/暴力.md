暴力
===============
### leetcode 864 获取要是的最短路径<br>
    图上有钥匙也有锁，拿到响应的钥匙才能开锁，求拿到所有要是的最短步数
    相当于多层最短路。
```c++
class Solution {
public:
    int dir[5]={1,0,-1,0,1};
    int dis[64][30][30];
    queue<pair<pair<int,int>,int> >q;
    int shortestPathAllKeys(vector<string>& grid) {
        int n=grid.size(),m=grid[0].size();
        int kn=0,sx,sy;
        memset(dis,-1,sizeof(dis));
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(grid[i][j]=='@'){
                    sx=i,sy=j;
                }else if(grid[i][j]>='A' and grid[i][j]<='Z'){
                    ++kn;
                }
            }
        }
        q.push({{sx,sy},0});
        dis[0][sx][sy]=0;
        int xx,yy,x,y,oldstate,newstate;
        while(!q.empty()){
            auto now=q.front();
            q.pop();
            x=now.first.first;
            y=now.first.second;
            oldstate=now.second;
            for(int i=0;i<4;++i){
                xx=x+dir[i],yy=y+dir[i+1];
                if(xx<0 or yy<0 or xx==n or yy==m)continue;
                if(grid[xx][yy]=='#')continue;
                if(grid[xx][yy]>='a' and grid[xx][yy]<='f'){
                    newstate=oldstate|(1<<(grid[xx][yy]-'a'));
                }
                else if(grid[xx][yy]<='F' and grid[xx][yy]>='A'){
                    if(!(oldstate&(1<<(grid[xx][yy]-'A')))){
                        continue;
                    }else{
                        newstate=oldstate;
                    }
                }else {
                    newstate=oldstate;
                }
                if(newstate+1==(1<<kn)){
                    return dis[oldstate][x][y]+1;
                }
                if(dis[oldstate][xx][yy]==-1){
                    dis[newstate][xx][yy]=dis[oldstate][x][y]+1;
                    q.push({{xx,yy},newstate});
                }
            }
        }
        return -1;
    }
};

```
