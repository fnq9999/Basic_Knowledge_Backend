


##树形DP<br>
###leetcode 124 二叉树中最大的路径和<br>




###leetcode 297 二叉树的序列化和反序列化<br>
    采用dfs的方法完成功能。x->left的赋值我见到的只是在本地函数内完成该操作，传到子函数完成操作，还没试过。
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // Encodes a tree to a single string.
    string int_string(int x){
        string s="";
        while(x){
            s=char('0'+(x%10))+s;
            x/=10;
        }
        return s;
    }
    int string_int(string &s,int x,int y){
        int ans=0;
        for(int i=x;i<=y;++i){
            ans=ans*10+s[i]-'0';
        }return ans;
    }
    void dfs(TreeNode* x,string &s){
        if(x==NULL){
            s+="# ";
            return ;
        }
        s+=int_string(x->val)+' ';
        dfs(x->left,s);
        dfs(x->right,s);
    }
    string serialize(TreeNode* root) {
        string tem="";
        dfs(root,tem);
        return tem;
    }
    // Decodes your encoded data to tree.
    TreeNode* dfs2(string &s,int &ind){
        if(ind>=s.size() or s[ind]=='#'){
            ind+=2;
            return NULL;
        }
        auto x=new TreeNode(0);
        int tem=0;
        for(;;++ind){
            if(s[ind]==' '){
                break;
            }
            tem=tem*10+s[ind]-'0';
        }
        ++ind;
        x->val=tem;
        x->left=dfs2(s,ind);
        x->right=dfs2(s,ind);
        return x;
    }
    TreeNode* deserialize(string data) {
        if(data=="" or data[0]=='#'){
            return NULL;
        }
        int kind=0;
        return dfs2(data,kind);
    }
};

// Your Codec object will be instantiated and called as such:
// Codec codec;
// codec.deserialize(codec.serialize(root));
```
