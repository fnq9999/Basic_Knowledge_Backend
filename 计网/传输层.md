TCP and UDP 介绍
================
### TCP 概念<br>
- TCP 特点
  - 面向连接
  - 点对点通信
  - 提供可靠交付
  - 全双工通信
  - 面向字节流
    - 将从应用进程收到的数据块都看成是字节流
- TCP可靠性
  - TCP提供可靠交付的服务：
    - 无差错：校验和机制，有差错直接将该报文丢弃，其他什么也不做。
    - 不丢失：累积确认和超时重传
    - 不重复：序号
    - 按序号到达：序号
  - 滑动窗口
  - 超时重传
    - RTT：加权平均来计算== (1-a)rtt_old+a*rtt_new
    - RTO：由上面的RTT+4RTT_D
    - RTT_D：RTT偏差的加权平均 beta一般0.25
  - SACK
    - 指明SACK需要1字节，说明SACK选项长度需要1字节
    - 一个段需要两个数据，每个数据4字节。
    - 会在TCP的首部开销很大


### TCP报文
- 首部默认20字节
- 字段常用标志位
  - URG
    - 为1时，紧急指针有效
  - ACK
    - 为1是，序列号字段有效
  - PSH
    - 接收方收到PSH为1的报文，立刻交给应用进程，而不是在缓冲区排队
  - RST
  - SYN
  - FIN

### 三报文握手，四报文握手<br>
  - 目的
    - 确知对方存在
    - 允许双方协商参数
    - 对运输实体资源进行分配
  - 三次的原因：
    - 应该是4次才能双方同时建立ISN，但是中间的那两次可以合并变为3次
      - ISN ：初始序号
        - 随机的原因:1.防止被旧连接中的报文干扰，2.防止被黑客猜到进行攻击。
  - 建立连接之后，客户端发生故障怎么办：
    - TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
  - 四次的原因：
    - 三次握手中合并的两次，如果被动断开方没有数据要发，那直接三次。
    
<img src="https://raw.githubusercontent.com/fnq9999/Basic_Knowledge_Backend/master/%E8%AE%A1%E7%BD%91/image/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" width="50%" /><br>


<img src="https://raw.githubusercontent.com/fnq9999/Basic_Knowledge_Backend/master/%E8%AE%A1%E7%BD%91/image/%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png" width="50%" /><br>

  - close_wait原因
    - 此时TCP服务器进程通知高层应用进程，A->B方向上连接断开
    - 若B->A发数据，A仍要接受数据。
    - 当B都准备好了，向A发送FIN时，该状态结束

  - 最后等待2MSL的时间：
    - 保证A发送的最后一个ACK到达B
    - 防止已经失效的连接请求报文段出现在本连接中，保证下一个新的连接中不会出现这种就得连接请求报文段。

### TCP 滑动窗口<br>
- 可靠传输
  - 以字节为单位
  - 以报文形式发送
  - 三个指针  p1 p2 p3 
    - p1 滑动窗口开始节点
    - p2 未发送开始点
    - p3 窗口外第一点
  - 确认
    - 双方同时通信可采用捎带确认的方式
    - 延迟确认不允许超过0.5s,超长报文应该及时确认
    - 发送方收到确认之后，调整滑动窗口，再进行发送
- 流量控制
  - 通过确认报文中的 rwnd来确定。
  - 零窗口时死锁问题
    - 若接受方修改零窗口的报文丢失了，会出现死锁
    - 发送方在接受到零窗口时，开启一个持续定时器，
    - 时间到了发送零窗口探测报文。
- 粘包和拆包
    - 粘包
        - 简言之就是 调用一次recv的，收到了对方两次独立send的数据（其实是归应用层管理的事情)
        - 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
        - 接收方法不及时读取套接字缓冲区数据，这将发生粘包。
        
    - 拆包
        - 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
        - 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度>MSS 的时候将发生拆包。
    - 解决方案
        - 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
        - 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
        - 在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。
        - 使用更复杂的应用层协议
        - 做好消息块的标识和消息块的分隔符，即使字节流让包粘在一起，数据的接受放依然可以根据消息块的分隔符将信息分离出来
      ```c++
        char tmp[];
        Buffer buffer;
        // 网络循环：必须在一个循环中读取网络，因为网络数据是源源不断的。
        while(1){
            // 从TCP流中读取不定长度的一段流数据，不能保证读到的数据是你期望的长度
            tcp.read(tmp);
            // 将这段流数据和之前收到的流数据拼接到一起
            buffer.append(tmp);
            // 解析循环：必须在一个循环中解析报文，应对所谓的粘包
            while(1){
                // 尝试解析报文
                msg = parse(buffer);
                if(!msg){
                    // 报文还没有准备好，糟糕，我们遇到拆包了！跳出解析循环，继续读网络。
                    break;
                }
                // 将解析过的报文对应的流数据清除
                buffer.remove(msg.length);
                // 业务处理
                process(msg);
            }
        }
        ```
    


### TCP 拥塞控制<br>
- Reno
    - 这里控制的窗口的单位其实是字节
    - 这里每次增大的1个单位原本是 MSS，
    - 但实际操作中，每次ACK都要增大一点，将原本窗口内都到达后一次增加的，进行拆分。
    - Increment = MSS x (MSS/CongestionWindow)CongestionWindow += Increment
  - 慢开始
    - 乘法增大
  - 拥塞避免
    - 加法增大
  - 快重传
    - 要求接受放受到报文就立刻确认，乱序的也要进行确认。
    - 当发送方收到三个重复的确认，立刻重发
  - 快恢复
    - ssthresh 变为拥塞发生时的一般，
    - cwnd变为ssthresh
- BBR

### TCP 报文何时发送<br>
  - 当缓存中的数据达到MSS时，发送报文
  - 发送方进程指明要求发送报文段，即TCP的PUSH 操作
  - 发送方的计时器到了，将缓存中的数据都发送
  - nagle算法
  - 糊涂窗口综合征问题：
    - 接收方只有一个字节的接受窗口，发送方不断发送一个数据字节的报文。这样来回收发效率十分低下
    - 可以让接收方等待一段时间，等到接受缓存有一般空闲的空间，再通知发送方。



### TCP 常见面试题<br>
- TCP常见面试题
  - 为什么三次，为什么四次
  - 三次握手过程中，可以携带数据吗
  - 已经建立了连接，客户端出现故障怎么办
  - 2MSL原因
    - 可靠终止TCP连接
    - 保证让迟来的TCP报文段有足够的的时间被识别的丢弃
    - 有时还希望避免TIME_WAIT状态，因为在TIME_WAIT状态该端口就不能立马进入到新的连接状态中，这时我们可以设置sock选项，复用addr来强制进程立即使用处于TIME_WAIT状态的连接端口。
  - SYN洪水攻击原理
    - 客户端发送一个SYN之后就不管了，服务器需要等待63sec才放弃该连接(消耗服务器资源)
    - 解决办法：syn_cookie
        - Filtering
        
        - 内核参数优化
            - Increasing backlog（tcp_max_syn_backlog）
            - Reducing SYN-RECEIVED timer or tcp_synack_retries 
            - SYN cookies
            - 限制syn并发数
        - Recycling the oldest half-open TCP
        - SYN cache
        - Hybrid approaches
        - Firewalls and proxies
        
        
  - RFC793明确规定，除了第一个握手报文SYN除外，其它所有报文必须将ACK = 1，RFC规定的背后肯定有合理性的一面，能否深究一下原因？
    - TCP作为一个可靠传输协议，其可靠性就是依赖于收到对方的数据，ACK对方，这样对方就可以释放缓存的数据，因为对方确信数据已经被接收到了。
  - 大量CLOSE_WAIT的原因
    - 对方关闭socket连接，我方忙于读写，没有及时关闭连接。
    - 程序有bug，忘记关闭连接。
    
    但TCP报文是在IP网络上传输，丢包是家常便饭，接收方要抓住一切的机会，把消息告诉发送方。最方便的方式就是，任何我方发送的TCP报文，都要捎带着ACK状态位。
  - ISN定义,ISN随机作用
    - 发送方字节数据编号原点
  - ACK 状态位能够独立承担消息传递任务

[车小胖关于TCP面试可能问到的问题](https://mp.weixin.qq.com/s/S1mv8AE_pQz3uHjRGS7tWg)


UDP
=======
### UDP特点<br>
- 无连接
- 支持多对多
- 尽最大交付
- 全双工
- UDP面向报文
  - 应用层给多少我就发多少，不做拆分
- 没有拥塞控制
- UDP首部开销小

### QUIC
[科普：QUIC协议原理分析——比较详尽](https://zhuanlan.zhihu.com/p/32553477)<br>
        是Google公司提出的基于UDP的高效可靠协议，他和HTTP一样同样是应用层协议。
- 拥塞控制   
- RTT
- SACK

        
#### 原理<br>






