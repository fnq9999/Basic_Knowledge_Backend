TCP通信异常
=======
[TCP通信的这些异常，你考虑了吗？](https://www.jianshu.com/p/d759788ab83f)
<br>

### 试图与一个不存的端口建立连接
- 服务端返回一个rst,客户端放弃该连接，并且向应用返回一个错误
### 试图与一个不存在的主机某端口建立连接
- 也相当于主机宕机，如果客户端TCP没有得到任何响应，
  那么等待6s之后再发一个SYN，若无响应则等待24s再发一个，
  若总共等待了75s后仍未收到响应就会返回ETIMEDOUT错误。
    - 当然75s是我们接受不了的，所以一般在connect函数中使用，超时参数，超时时间
    到达，仍未建立连接，那么返回超时错误

### server被阻塞
- 这时候连接是正常建立的，并且也会收到一个server的内核发来的ack，但是因为进程阻塞住，
那么永远不会返回结果
  
### 终止掉正在服务的server
- 进程退出时，会将文件描述符都close掉，对于socket来说，相当于关闭连接，执行四次挥手

### Server进程所在的主机关机
- 实际上这种情况不会带来什么更坏的后果。在系统关闭时，init进程会给所有进程发送SIGTERM信号，等待一段时间（5~20秒），然后再给所有仍在运行的进程发送SIGKILL信号。当服务器进程死掉时，会关闭所有文件描述符。带来的影响和上面杀死server相同。


### Server进程所在的主机宕机
- 客户端write函数成功返回并不能表明收到一个对方的ack,所以客户端的write成功之后，
  会阻塞在read函数，客户端收不到ack，于是重传试图收到ack，然而服务器始终不能应答，
  重传数次之后，大约4~10分钟才停止，之后返回一个ETIMEDOUT错误。
  
- 解决：
    - 用SO_KEEPALIVE的套接字选项——相当于心跳包，每隔一段时间给
      对方发送一个心跳包，当对方没有响应时会一更短的时间间隔发送，
      一段时间后仍然无响应的话就断开这个连接
      
### 服务器进程所在的主机宕机后重启
- 服务器端所在主机的TCP丢失了崩溃前所有连接信息，
  即TCP收到了一个根本不存在连接上的分节，所以会响应一个RST分节





