### 项目介绍<br>
  C实现的静态web服务器，支持get请求，
### 技术点概要<br>
- 模拟proactor模式+EPOLL(LT+ET)
- 线程池避免频繁创建撤销进程
- 定时器
- 状态机解析HTTP请求
### 技术点细节<br>
- EPOLL
  - listenfd：LT
    - 最早采用ET模式进行处理，并且没有使用while(1)accept;在压测过程中发现出现大量的并发发生后，若再使用小于listen(2)中的backlog个参数的客户进行压测的话，程序会僵死。抓包以及查看accept取出的端口来看发现，得到的客户端端口并不是新建立连接的端口，进一步学习了解到，有半连接队列的全连接队列的概念，epoll确实通知了我们有新的established的sockfd，可从accept里面取出来的首先是是队列首部的，这个sockfd的客户端早已挂掉，内核向对方发送一个ack之后，对方返回RST，在下一次EPOLL通知后，服务器就关闭该连接。所以backlog个客户的连接可以将原来全连接队列中的sockfd在这种Bug的情况下，给挤下去，最后只有c-backlog个客户连接了服务器。从客户端的角度来看，客户端正常建立了socket，因为对方半连接队列没有满，对方返回[syn,ack],我客户端connect成功，然后客户端直接向服务器发送了数据，然而服务器这时候并没有accept该sockfd,客户端一直在等待对方的数据。
    - 在采用了LT之后，还是没有使用while，出现了半连接队列满的情况。这种情况客户端是connet不成功的，服务器无法接受更多个SYN_REVD状态的socKet。这样服务器就不能相对方发出[SYN,ACK],这样也就不能得到新的established得sockfd，所以服务器也僵死了。
    - 最后使用LT+while(1)解决了问题。    
  - connfd：ET
- 线程池
  - 半同步/半反应堆线程池
  - 主线程
    - 负责
    EVENTLOOP
  - 子线程
    - 
  - 工作队列
- IO方法
  - mmap
    - 使用mmap方式打开文件避免了从内核缓冲区到用户空间这样一个步骤。
  - writev()
    - 集中写的方式发送数据，这样就可以避免把数据在用户空间拼成一块，这样一个步骤。
- 定时器
  - 升序链表定时器
    - 使用ALARM信号，周期性地处理非活动连接。
### 性能分析<br>






