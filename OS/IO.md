多路IO
=========

## 三组I/O复用函数的比较

select、poll和epoll三组系统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返回值是就绪的文件描述符的数量。下面从事件集、最大支持文件描述符、工作模式和具体体现等四方面进一步比较它们的异同，以明确在实际应用中如何选择。

| 系统调用                               | select                                                       | poll                                                         | epoll                                                        |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事件集合                               | 用户通过3个参数分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件，这使得每个用户每次调用都要重置这三个参数 | 统一处理所有时间类型，因此只需要一个事件参数集。用户通过`pollfd.events`传入感兴趣的事件，内核通过修改`pollfd.revents`反馈其中的就绪事件 | 内核通过一个事件表直接管理用户感兴趣的事件。因此每次调用`epoll_wait`时，无需反复传入用户感兴趣的时间。`epoll_wait`系统调用的参数events仅用来反馈就绪的事件 |
| 应用程序索引就绪文件描述符的时间复杂度 | O(n)                                                         | O(n)                                                         | O(1)                                                         |
| 最大支持文件描述符数                   | 一般有最大限制FD_SIZE                                        | 65535                                                        | 65535                                                        |
| 工作模式                               | LT                                                           | LT                                                           | ET                                                           |
| 内核实现和工作效率                     | 采用轮询的方式来检测就绪时间，算法时间复杂度为O(n)           | 采用轮训方式来检测就绪事件，算法时间复杂度为O(n)             | 采用回调方式来检测就绪事件，算法时间复杂度为O(1)             |

epoll_wait采用回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件对了。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。

但是，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高。因为此时回调函数被触发得过于频繁。所以epoll_wait适用于连接数量多，但活动连接较少的情况。


## 应用场景<br>

1. select应用场景 select的timeout参数精确到1ns，而poll和epoll为1ms，因此select更加实用与实时性要求更高的场景；<br>

select可移植性更好，几乎被所有主流平台所支持；<br>

2. poll应用场景 poll没有最大描述符数量的限制，如果平台支持并且实时度要求不高的话，应该使用poll而不是select。<br>

3. epoll应用场景 只需要运行在Linux平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。<br>

需要监控小于1000个描述符，就没有必要使用epoll，因为这个应用场景下，并不能体现出epoll的优势。<br>

需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用epoll。因为epoll中所有的描述符都存储在内核中，造成每次都需要对描述符的状态改变都需要通过epoll_ctl进行系统调用，频繁的系统调用减低了效率，并且epoll的描述符存储在内核不容易调试；<br>
