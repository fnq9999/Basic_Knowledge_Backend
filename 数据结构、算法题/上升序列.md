上升序列
=============
### leetcode300 最长上升子序列
```cgo
- 如果大于末尾就PUSH_BACK
- 否则就让从左数第一个大于的让那个数变小
class Solution {
public:
    int lengthOfLIS(vector<int>& a) {
        vector<int>ans;
        ans.push_back(a[0]);
        for(int i=1;i<a.size();++i){
            int x=a[i];
            if(x>*(ans.end()-1)){
                ans.push_back(x);
            }else{
                auto it =lower_bound(ans.begin(),ans.end(),x);
                *it=x;
            }
        }
        return ans.size();
    }
};
```


### leetcode646 最长数对链
        题目给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。
          现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 
          给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

- 解
    - 首先在最前面放一个虚点
    - 如果左端点比末尾右端点大，那么直接push
    - 否则找到右端点第一个大于的，如果找到的位置的前一个右端点小于要push的左端点，那么push
```cgo
class Solution {
public:
    int findLongestChain(vector<vector<int>>& a) {
        vector<vector<int>>ans;
        sort(a.begin(),a.end());
        ans.push_back(vector<int>{-1010,-1001});
        for(int i=0;i<a.size();++i){
            if(a[i][0]>ans[ans.size()-1][1]){
                ans.push_back(a[i]);
            }else{
                int l=0,r=ans.size()-1;
                while(l<r){
                    int mid=(l+r)>>1;
                    if(ans[mid][1]>=a[i][1]){
                        r=mid;
                    }else{
                        l=mid+1;
                    }
                }
                if(ans[l-1][1]<a[i][0] and a[i][1]<ans[l][1]){
                    ans[l]=a[i];
                }  
            }
            // for(int i=0;i<ans.size();++i){
            //     cout<<ans[i][0]<<' '<<ans[i][1]<<endl;
            // }
           // cout<<"----------------------"<<endl;
        }
        return ans.size()-1;
    }
};
```

### leetcode491 递增子序列
        给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

- 解
    - 思路1：二进制枚举
    - 思路2：dfs   
        - 每一个位置由两种选择，选和不选
            - 选：  只有当后面的元素大于等于前面的元素，那么直接可以选择
            - 不选：在这里做限制就可以解决重复问题。重复出现的原因是在 两元素val相等时，前选+后不选==前不选+后选
            所以我们在这里限制只允许不选的时候只允许不允许前面相等--->只允许val相等时的前不选+后选 
```cgo
class Solution {
public:
    vector<vector<int>> ans;
    #define pb push_back
    void dfs(vector<int>&a,int ind,vector<int>&tem,int len){
        if(ind==len){
            if(tem.size()>=2)
                ans.pb(tem);
            return ;
        }
        if(tem.size()==0 or a[ind]>=*(tem.end()-1)){
            tem.pb(a[ind]);
            dfs(a,ind+1,tem,len);
            tem.pop_back();
        }
        if(tem.size()==0 or a[ind]!=*(tem.end()-1)){
            dfs(a,ind+1,tem,len);
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& a) {
        vector<int>tem;
        tem.clear();
        dfs(a,0,tem,a.size());      
        return ans;
    }
};
};
```
