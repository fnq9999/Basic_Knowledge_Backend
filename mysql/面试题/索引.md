索引
=====================
### 数据结构
&emsp;B树和B+树都是用来在硬盘存储数据的数据结构，因为全部数据无法在内存中存储
#### B树
- 基本性质
    - 叶子都在一层
    - A B-tree of order m 最多m-1关键字  m个子节点，关键字都按大小排序。
    - 每个节点最多m子节点
    - 根节点至少两个子节点
    - 除了根节点和叶子节点，每个节点至少m/2子节点    
    - 每个节点存储的索引和数据，对应的就是key和value（这里的数据指的并不是全部数据，具体要看是聚簇还是非聚簇，聚簇全部，非聚簇主键值）
    
#### B和B+的区别
- B+树所有叶子节点都用指针连接一起这样范围查询简单，B树无
    - B树:实在没找到，可能要去看源码，但是从最简单的二叉树范围查找可以推出来，应该是中序遍历，在遍历过程中加if，满足条件才遍历子树，
    - B+:范围查询：找到最左，需要对链表进行遍历就行了
    - <img src="https://img-blog.csdn.net/20180430140658178"  width="50%">

- 数据存储在叶子节点，**非叶子节点只用来做索引** ，这样树更矮，索引更快
- B+树非叶子节点的指针和关键字数量相同
- 非叶子节点的子树指针p[i]，指向关键字,[k[i],k[i+1])的子树， 

#### 生产中B+树一般多高
参考:[为什么生产环境中B+树的高度总是3-4层？](https://zhuanlan.zhihu.com/p/86137284)
- 通常1-3层
- 原因    
    - 1170 * 1170 * 16 =21902400 行数据 ，已经很大，再大就要拆表
        - InnoDB 存储引擎也有自己的最小储存单元——页（Page），一个页的大小是 16K
        - 一行数据一般为1k大小
        - 一个叶节点（页在Innodb）记录数 =16K/1K=16
        - 我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。

#### 场景选择
参考:[为什么 MongoDB 索引选择B树，而 Mysql 选择B+树（精干总结）](https://zhuanlan.zhihu.com/p/102628897?utm_source=qq)
- B+树
    - **磁盘**读写代价低，更适合做存储索引
    - 查询效率更加**稳定**，所有关键字查询都相同
    - **范围**查询更高效
    - 数据关系性强的应该用B+树
- B树
    - MongoDB使用（文档型数据库，数据无关联）
    - 找到节点就找到数据，更快
    
### 索引方式 
参考:[DBMS - Indexing_tutorialspoint.com](https://www.tutorialspoint.com/dbms/dbms_indexing.htm)
- 按索引属性分
    - 主键索引
    - 二级索引(辅助索引or非聚簇索引)（候选键or 有重复值的non-key ）
        - 叶子节点只存储了主键值，想找到数据需要再次主键索引
    - 聚簇索引
        - 一张表只能按照一个B+树排序，数据都存在这个B+树的叶子节点了，一个叶子节点存储了一个数据叶，数据叶默认16K大小，所以通常
        可以存储16条数据
        - 数据页在磁盘中并不是物理上连续的，而是通过指针形成的双向链表，在逻辑上是连续的。因为物理上连续维护成本会非常高。
        
    - 聚集索引和非聚集索引区别
        - 叶子节点的区别
        - 非聚簇索引的叶子节点并不包含行记录的所有数据，它只是包含行数据的主键，得到全部数据需要再次聚簇索引。
- Ordered Indexing is of two types    
    - 密集索引：数据库中的每一个项都有对用的index record
        - <img src="https://www.tutorialspoint.com/dbms/images/dense_index.png" width="30%">
    - 稀疏索引: 并不是一一对应,想找到一条数据可能需要被一个index record到达数据库中一处，然后顺序搜索，找到需要的数据。这种方式索引结构占用空间小
        - <img src="https://www.tutorialspoint.com/dbms/images/sparse_index.png" width="30%">
    
    
#### 全文索引
参考[时间序列数据库的秘密(二)——索引——图很好！！](http://www.uml.org.cn/sjjm/2015090110.asp)<br>
参考[MySQL · 引擎特性 · InnoDB 全文索引简介 ](http://mysql.taobao.org/monthly/2015/10/01/)<br>
- 基本结构
    - 6个辅助索引表存储倒排索引根据分词的第一个字符值进行分区
    - 其他几个缓存表，用来缓存删除操作，
        - _DELETED_CACHE，_BEING_DELETED_CACHE，_BEING_DELETED
        - 删除操作不可能每次都操作磁盘
    - CONFIG表
        
- 创建全文索引的过程
    - InnoDB采用了fork多个线程进行并发构建全文索引项的方法
- 全文索引不是非常准确？（为什么）
    - 模糊，词的同义等等

- Lucene的全文索引
    - 使用倒排索引技术 
    - <img src="http://www.uml.org.cn/sjjm/images/201509011005.jpg" width="40%" > 
        - Term Index:一个 Trie ,储存所有单词的部分前缀，该结构存储在内存当中，用来减少在磁盘中的random access。
        - Term Dictionary：前面的Term Index 帮助我们快速定位到其中Term Dictionary Offset当中，之后顺序查找即可
        - Positoin list：存储单词在哪个document,并且是document的第几个单词

#### 其他索引
- 哈希索引
- 前缀索引

### 唯一索引和主键索引的区别
- 主键不可以有空值，唯一索引可以有空值，但是唯一索引的多个空值是算作重复的。
- 主键可以算是唯一索引的特殊版
- 主键可以作为外键，唯一不可以
- 主键可以是多个字段的组合，唯一不是
- 主键每个表只有一个，在一个表中可以建立多个唯一索引。







### 联合索引
- 联合索引在InnoDB中只建立了一课B+树，只是按照多个关键字进行排序而已。
- 索引的时候，只要出现了第一个关键字就可以利用索引，不包含第一个关键字就用不到索引。

### 索引慢该怎么办
参考:[腾讯面试：一条SQL语句执行得很慢的原因有哪些？ ](https://juejin.cn/post/6844903829150892039)
- 分情况
    - 偶尔很慢
    - 数据量不变的情况下，一直都慢
- 偶尔很慢
    - 1、redo log满的情况下，数据库在把数据同步到磁盘，这时sql会执行的很慢
    - 2、这条语句涉及到的数据被加锁了，只能等待，若要判断是否真的被加锁了应该使用 show processlist命令
- 一直都慢
    - 字段上本来就没有索引
    - 或者有索引但没用到索引
        - 约束条件中嵌套表达式：
        select * from t where c - 1 = 1000;
        - 函数操作导致没有用上索引
        select * from t where pow(c,2) = 1000;
        - 模糊查询
    - 数据库自己选错索引了
        - 数据库自己判断的不需要索引不合适  
            - 它发现走辅助索引的话，满足条件的量比较大，辅助索引找到了还要在走一遍主键索引，这样下来很不划算   
                - 因为走主键索引相当于对于磁盘的频繁离散读操作。这样的话，不如直接走全表扫描，顺序读操作
            - 判断的几个变量
                - 基数：采样得到，描述的是一个索引不同的值的多少，相同的值越少，那么区分度越好，基数越大。走索引越合适。（缺点就是采样就有可能有失误）
                
                
