数据结构
=====

### String
- 动态字符串
```cgo
struct sdshdr {

    int len;        //buf中已占用空间的长度

    int free;       //buf中剩余可用空间的长度

    char buf[];     //初始化sds分配的数据空间，而且是柔性数组（Flexible array member）

};
```

- 兼容C的一些处理字符串的函数，因为它的基本结构
- 二进制安全，因为它的结构当中，包含了长度变量，所以以前的结尾符号不会
终端字符串
- 获取长度复杂度O(1)
- 杜绝缓冲区溢出，因为表头的存在
- 空间预分配策略
    - 如果free的长度大于 要扩展的长度，那么不懂
    - 不够用的话，那么如果新的长度小于1M，那么最后新的长度为，预达到长度的2倍
    - 如果大于1M的话，那么最后占用的字符串空间为newLen+1M
```cgo
sds sdsMakeRoomFor(sds s, size_t addlen) {      //对 sds 中 buf 的长度进行扩展
    struct sdshdr *sh, *newsh;
    size_t free = sdsavail(s);  //获得s的未使用空间长度
    size_t len, newlen;

    //free的长度够用不用扩展直接返回
    if (free >= addlen) return s;  

    //free长度不够用，需要扩展
    len = sdslen(s);    //获得s字符串的长度
    sh = (void*) (s-(sizeof(struct sdshdr)));       //获取表头地址
    newlen = (len+addlen);  //扩展后的新长度

    //空间预分配     
    //#define SDS_MAX_PREALLOC (1024*1024)  
    //预先分配内存的最大长度为 1MB
    if (newlen < SDS_MAX_PREALLOC)  //新长度小于“最大预分配长度”，就直接将扩展的新长度乘2
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC; //新长度大于“最大预分配长度”，就在加上一个“最大预分配长度”
    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);   //获得新的扩展空间的地址
    if (newsh == NULL) return NULL;

    newsh->free = newlen - len; //更新新空间的未使用的空间free
    return newsh->buf;
}
```
### List

### Set

### Hash

### ZSet


