### 项目介绍<br>
  C实现的静态web服务器，支持get请求，
### 技术点概要<br>
- 模拟proactor模式+EPOLL(LT+ET)
- 线程池避免频繁创建撤销进程
- 定时器处理非活动连接
- 有限状态机解析HTTP请求
- 同步异步日志
### 技术点细节<br>
- EPOLL
  - listenfd：LT
    - 最早采用ET模式进行处理，并且没有使用while(1)accept;在压测过程中发现出现大量的并发发生后，若再使用小于listen(2)中的backlog个参数的客户进行压测的话，程序会僵死。抓包以及查看accept取出的端口来看发现，得到的客户端端口并不是新建立连接的端口，进一步学习了解到，有半连接队列的全连接队列的概念，epoll确实通知了我们有新的established的sockfd，可从accept里面取出来的首先是是队列首部的，这个sockfd的客户端早已挂掉，内核向对方发送一个ack之后，对方返回RST，在下一次EPOLL通知后，服务器就关闭该连接。所以backlog个客户的连接可以将原来全连接队列中的sockfd在这种Bug的情况下，给挤下去，最后只有c-backlog个客户连接了服务器。从客户端的角度来看，客户端正常建立了socket，因为对方半连接队列没有满，对方返回[syn,ack],我客户端connect成功，然后客户端直接向服务器发送了数据，然而服务器这时候并没有accept该sockfd,客户端一直在等待对方的数据。
    - 在采用了LT之后，还是没有使用while，出现了半连接队列满的情况。这种情况客户端是connet不成功的，服务器无法接受更多个SYN_REVD状态的socKet。这样服务器就不能相对方发出[SYN,ACK],这样也就不能得到新的established得sockfd，所以服务器也僵死了。
    - 最后使用LT+while(1)解决了问题。   
  - connfd：ET
- 线程池
  - 半同步/半反应堆线程池
  - 主线程
    - 负责
    EVENTLOOP
  - 子线程
    - 
  - 工作队列
- IO具体方法
  - recv(2)
  - mmap(2)
    - 使用mmap方式打开文件避免了从内核缓冲区到用户空间这样一个步骤。
  - writev(2)
    - 集中写的方式发送数据，这样就可以避免把数据在用户空间拼成一块，这样一个步骤。
- 定时器
  - 升序链表定时器用ALARM信号，周期性地处理非活动连接。
    - 使
- 日志
  - 异步日志
    - 生产者消费者模型
      - Log类实例时，创建一个用来处理阻塞队列中的string的子进程,
      - getinstacne()->write_log(string)时
        - 判断写入的是什么类型log
        - 如果恰好进入第二天或者，日志行数超过一个日志的行数限制，就创建新的文件（该部分加锁）
        - 向缓冲数据当中写入格式化时间以及string
        - 放入阻塞队列当中
    - 阻塞队列
      - 互斥锁+条件变量
  - 同步日志
    - 与异步日志不同的是，同步直接向打开的文件描述符当中写入数据。

### 性能分析<br>






