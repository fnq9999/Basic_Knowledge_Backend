分布式锁
=====

### Golang
- redis分布式锁
```cgo

type rlk struct{
    key string
    uuid string
}

func (l *rlk) Lock(ctx context.Context,expTime ,retryTime time.Duration)error{
    if err:=l.rawLock(ctx,expTime,retryTime);err!=nil{
        if err==AlreayLocked{
            log.Errorf("err:%+v",err)
            return err
        }
        _ = l.UnLock(ctx)
        return err
    }
    return nil
} 

func (l *rlk) UnLock(ctx context.Context)error{
    tmp:="if redis.call('get',KEYS[1])==ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"
    if err:=retry.Do(ctx,func()error{
        return GetRedis(ctx).Eval(tmp,[]string{l.key},l.uuid).Err()
    });err!=nil{
        log.Fatalf("Fatal:%+v",e)
        return err
    }
    return nil
} 

func (l *rlk) rawLock(ctx context.Context,expTime,retryTime)error{
    if err:=retry.Do(ctx,retryTime,retryCnt,func ()error{
        Locked,err =GetRedis(ctx).SetNX(l.key,l.uuid,expTime)
    });err!=nil{
        return err
    }
    if !Locked{
        return AlreayLocked   
    }
    return nil 
} 
// 存在的问题，当master崩掉，slave变master,但是slave此时还没同步到master当中的key,
导致可能又有客户端对key上锁，从而出现问题

```

- zetcd锁，zk锁
    - 为什么使用:因为他们主从保证了强一致性