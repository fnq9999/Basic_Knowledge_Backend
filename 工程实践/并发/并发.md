并发
=====

### 锁
- 最佳实践
    - 减少持有时间，缩小临界区
    - 优化锁的粒度
    - 读写分离:使用读写锁
    - 原子操作
    
- BadCase
    - 忽略锁的可重入性
    - golang总使用race detector 发现问题
- 追求极致
    - golang
        - Mutex太慢
        - 读写锁能优化一些
        - 原子操作虽然快，单没到极致  
        - UnsafePointer最快，只有一条访存指令
    
- 锁演变
    - 80386处理器，只需要关闭中断，就能实现原子操作，但是需要进入内核态，所以性能
    不好
    - Lock+CMPSWAP(Lock 前缀锁定内存总线，内存总线为瓶颈)
    - P4 系列CPU：MESI 缓存一致性协议:锁的粒度->CacheLine
    - 自旋锁
    - Mutex:
        - golang:效率优先，兼顾公平
    
### 限流算法
- 单机限流
    - 计数器
        - 实现:计数器超过一定值不处理后续请求，当超过TimeInterval,cnt清零
        - 问题:突刺线性
        - 演变：滑动窗口算法 ，该方法对比于普通的计数器方法划分了更小的粒度，
    窗口内划分了更多的小格，每个小格都是一个计数器，当窗口内数量达到上限，不接受请求， 否则接受请求
          - ![](.并发_images/d18ac2bc.png)
    - 漏桶
        - 特点:以固定的速度流出水
        - 问题：桶满了，请求丢弃
    - 令牌桶
        - 特点:系统以恒定的速度产生令牌，将这些令牌放入一个令牌桶当中，多余的令牌丢弃，每一个请求消耗一个令牌，
    当没有令牌时，该请求无效
        - 相比漏桶的好处:
            - 令牌桶算法能够在限制数据的平均传输速率的同时还允许
              某种程度的突发传输。漏桶算法对于存在突发特性的流量来说缺乏效率


- 分布式限流
- 背景:若想实现分布式全局限流
```cgo

-- 计数器限流
-- 此处支持的最小单位时间是秒, 若将 expire 改成 pexpire 则可支持毫秒粒度.
-- KEYS[1]  string  限流的key
-- ARGV[1]  int     限流数
-- ARGV[2]  int     单位时间(秒)

local cnt = tonumber(redis.call("incr", KEYS[1]))

if (cnt == 1) then
    -- cnt 值为1说明之前不存在该值, 因此需要设置其过期时间
    redis.call("expire", KEYS[1], tonumber(ARGV[2]))
elseif (cnt > tonumber(ARGV[1])) then
    return -1
end 

return cnt
```


### 线程池设置多大

- IO密集型
    - 其实意思是经常碰到阻塞的，如果采用IO多路复用+NIO的话，那么可以转成CPU密集型???
    - 线程数:CPU 核心数 *（1+平均等待时间/平均工作时间）
    - 通常 只要你的线程数，不会导致明显的上下文切换损耗，而且不会造成内存溢出，线程池就可以设置的足够大
- CPU密集型
    - 线程数：CPU 核心数 *（1+平均等待时间/平均工作时间）
    - 通常设置为2倍核心数:之所以不是一倍是因为，操作系统中还有别的线程，
      因此，你需要在更多的争抢机会和更少的上下文切换之间取得平衡





